# 11-2. EL 기초
## EL의 데이터 타입과 리터럴
EL은 불리언(Boolean) 타입, 정수 타입, 실수 타입, 문자열 타입 그리고 널 타입의 5가지 타입을 제공하고 있다.
```jsp
${10}은 정수, ${10.1}은 실수
```
***
## EL의 기본 객체
JSP는 EL에서 사용할 수 있는 기본 객체도 제공하고 있다. 
이 객체를 이용해서 요청 파라미터나 세션 속성값 등을 표현 언어에서 사용할 수 있다.

![image](https://github.com/GYUNGAEEEE/JSP/assets/158580466/bcddea03-7da6-4700-aae4-01837852e68c)

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%
	request.setAttribute("name", "홍길동");
%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

요청 URI: ${pageContext.request.requestURI}<br/>
request의 name 속성: ${requestScope.name}<br/>
code 파라미터: ${param.code}

</body>
</html>
```
EL은 값이 존재하지 않는 경우(null) 아무것도 출력하지 않는다.
```jsp
${cookie.ID.value}
```
표현 언어의 cookie 기본 객체는 <쿠키 이름, Cookie 객체> 맵이기 때문에 cookie.ID는 이름이 ID인 Cookie 객체를 리턴한다. 
따라서 cookie.ID.value가 출력하는 값은 이름이 ID인 Cookie 객체의 getValue() 메서드가 리턴한 값이 된다. 
이름이 "ID"인 쿠키가 존재하지 않으면 아무 값도 출력하지 않는다.
***
## 객체 접근
EL 언어는 객체에 저장된 값에 접근할 때 점(.)이나 대괄호([])를 사용한다. 
이 두 연산자는 동일한 연산자로서 cookie.name과 cookie.['name']은 같은 결과를 리턴한다.
***
## 객체 탐색
EL에서 PAGE, REQUEST, SESSION, APPLICATION 영역에 저장된 속성에 접근할 때에는 
pageScope, requestScope, sessionScope, applicationScope 기본 객체를 사용한다.
```jsp
${pageScope.Name}
```
영역을 나타내는 EL 기본 객체를 사용하지 않고 이름만 지정하는 경우 EL은 네 개의 영역을 차례대로 검색해서 속성이 존재하는지 확인한다. 
```jsp
${name}
```
이 EL 요소는 PAGE, REQUEST, SESSION 그리고 APPLICATION 영역을 차례대로 검사해서 
이름이 name인 속성이 존재하는지 확인하고 존재하는 경우 그 속성의 값을 사용한다.
***
## 수치 연산자
수치 연산자는 +, -, *, /(또는 div), %(또는 mod), -(단항 연산자)가 있다.

수치 연산자는 정수 타입과 실수 타입에 대해서만 동작한다. 
숫자 타입과 객체를 수치 연산자와 함께 사용하는 경우 해당 객체를 숫자로 변환한 후에 연산을 수행한다.
```jsp
${"10" + 1}
```
"10"을 숫자로 먼저 변환하고 그다음에 연산을 수행하기 때문에 결과는 숫자 11이다.
만약 숫자로 변환할 수 없는 객체와 수치 연산자를 함께 사용하면 에러가 발생한다.

나누기 연산은 실수 타입(BigDecimal이나 Double)을 결과로 갖는다.
단항 뺄셈 연산자는 음수를 양수로, 양수를 음수로 변환한다.
수치 연산의 특징은 값이 null이면 정수 타입 0을 값으로 사용한다.
또, 정수 타입보다 실수 타입을 우선한다.
***
## 비교 연산자
EL에서 제공하는 비교 연산자에는 ==(또는 eq), !=(또는 ne), <(또는 lt), >(또는 gt), <=(또는 le), >=(또는 ge)가 있다.
숫자의 경우 자바 연산자와 동일한 방법으로 사용되며, 문자열을 비교할 경우 String.compareTo() 메서드를 사용한다.
```jsp
${someValue == '2004'}
```
이 코드는 (someValue.compareTo("2004") == 0)과 같은 의미를 지닌다.
문자열뿐만 아니라 객체도 compareTo() 메서드를 사용하여 객체가 같은 값을 갖는지를 비교한다.
***
## 논리 연산자
EL은 &&(또는 and), ||(또는 or), !(또는 not) 논리 연산자를 제공한다.
이들은 자바 언어의 연산자와 완전히 동일하다.
***
## empty 연산자
empty 연산자는 검사할 객체가 텅 빈 객체인지를 검사하기 위해 사용한다.
```
empty <값>
```
***
## 비교 선택 연산자
```
<수식> ? <값1> : <값2>
```
<수식>의 결과값이 true이면 <값1>을 리턴하고, false이면 <값2>를 리턴한다.
***
## 문자열 연결
앞서 수치 연산자에서 설명했듯이 + 연산자는 피연산자를 숫자로 변환한 뒤에 연산을 수행하기 때문에 
변환 불가능한 피연산자를 + 연산하면 에러가 발생한다.
EL 3.0 버전에 문자열 연결을 위한 += 연산자가 추가됐다.
```
${"문자" += "열" += "연결"}
```
***
## 컬렉션
EL 2.2 버전은 컬렉션을 위한 표현 방식을 지원하지 않았다. 
그래서 List 객체를 생성해서 EL에서 사용하려면 스크립트릿을 이용해서 List 객체를 생성해야 했다.

EL 3.0 버전부터 EL 식에서 직접 List, Map, Set 타입의 객체를 생성할 수 있게 되었다.
```jsp
<c:set var="vals" values="${ [1, 2, 5, 10] }"/>
${myfunc:sum(vals)}

${myfunc:sum( [1, 2, 5, 10] )}
```
List의 각 항목에 접근할 때는 변수명[인덱스] 형식을 사용한다.
```
${vals[2]}
```
Map 타입의 컬렉션 객체를 생성할 때에는 다음과 같이 사용한다.
```jsp
<c:set var="mem" value="${ {'name':'홍길동', 'age':20} }"/>
${mem.name}, ${mem.age}
```
Set 타입의 EL 객체를 생성할 때는 다음과 같이 사용한다.
```
<c:set var="hangul" value=${ {'가', '나', '다'} }"/>
${hangul}
```
Map과 List를 혼합해서 생성할 수도 있다.
```
<c:set var="codes" value=${ [{'code':'001', 'label':'1번'}, {'code':'001', 'label':'1번'}] }"/>
${codes[0].code}, ${codes[0].label}
```
***
## 세미콜론 연산자
EL 3.0에 추가된 연산자로서, ${A ; B}의 EL을 사용하면 A값은 출력되지 않고 B값만 출력한다.
***
## 할당 연산자
앞서 EL 변수를 생성하기 위해 다음의 두 코드 중 하나를 사용했다.
```jsp
<% request.setAttribute("var1", 10L); %>
또는
<c:set var="var1" value="${10}"/>
```
EL 3.0 버전은 할당 연산자를 제공한다.
```jsp
${ var1 = 10 }
```
할당 연산자를 사용할 때 주의할 점은 할당 연산자 자체도 출력 결과를 생성한다는 점이다.
즉, 위 코드를 실행하면 응답 결과로 10이 출력된다.
보통은 할당 연산자의 결과를 응답 결과에 포함시킬 이유가 없기 때문에, 
세미콜론 연산자를 함께 사용하면 할당 연산자의 결과 대신 빈 문자열을 결과로 출력할 수 있다.
```
${hangul = ['가', '나', '다'] ; ''}
```
***
## 연산자 우선순위
- [] .
- ()
- -(단항) not ! empty
- \* / div % mod
- \+ -
- +=
- < > <= >= lt gt le ge
- == != eq ne
- && and
- || or
- ? :
- ->
- =
- ;

위쪽에 있는 것의 우선순위가 높고 같은 줄에 표시한 연산자의 우선순위는 동일하다. 
우선순위가 같은 경우 실행 순서는 왼쪽에서 오른쪽으로 진행된다.
***
## 특수 문자 처리하기
역슬래시(\) 뒤에 ${ 이나 #{ 문자를 위치시키면 된다.
